# 6. 응용서비스와 표현영역

## 표현 영역과 응용 영역

### 표현영역
표현영역은 사용자의 요청을 해석합니다
표현영역은 URL, 요청 파라미터, 쿠키, 헤더 등을 이용해 사용자가 어떤 기능을 실행하고 싶어하는지 판별하고 그 기능을 제공하는 응용서비스를 실행합니다.

### 응용영역
실제 사용자가 원하는 기능을 제공하는 것 은 응용영역의 서비스 입니다.
응용서비스는 기능을 실행하는데 필요한 입력값을 메서드 파라미터로 전달받고 실행결과를 리턴합니다.

```java
@RequestMapping(value=“/member/join”)
public ModelAndView join(HttpServletRequest request) {
	String email = request.getParameter(“email”);
	String password = request.getParameter(“password”);
	JoinRequest joinReq = new JoinRequest(email, password);
	joinService.join(joinReq);
}
```


## 응용 서비스의 역할
응용서비스는 사용자가 요청한 기능을 수행합니다.

리포지토리로부터 도메인 객체를 구합니다.
모데인 객체를 사용합니다.
표현영역 입장에서 보았을 때 응용서비스는 도메인 영역과 표현영역을 이어주는 파사드 역할을 합니다.
도메인의 상태 변경을 트랜잭션을 처리합니다.

```java
public Result doSomeFunc(SomeReq req) {
	someAgg  agg = someAggrepository.findById(req.getId());
	agg.doFunc(req.getvalue());
	return createSuccessResult(agg);
}
```

```java
public Result doSomeCreate(CreateSomeReq req) {
	// 1. 데이터 중복 등 데이터가 유효한지 검사합니다.
	checkValid(req);
	// 2. 애그리거트를 생성합니다.
	someAgg newAgg = createSome(req);
	// 3. 리포지터리에 애그리거트를 저장합니다.
	someAggRepository.save(newAgg);
	// 4. 결과를 리턴합니다.
	return createSuccessResult(newAgg);
}
```

응용 서비스가 이것보다 복잡하다면 응용서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높습니다.

한 번에 다수 회원을 차단 상태로 변경하는 응용서비스를 생각해 보면
차단 대상이 되는 Member애그리거트 목록을 구하고 차례대로 차단 기능을 실행할 것입니다.

```java 
public void blockMembers(String[] blockIds) {
	if (blockIds == null || blockIds.length == 0) return ;
	List<Member> members = memberRepository.findByIds(blockIds);
	for (Member mem: members) {
		mem.block();
	}
}
```

만약 이 경우에서 메서드가 트랜잭션 범위에서 실행되지 않는 경우, Member객체의 block()메서드의 변경 상태를 DB에 반영하는 도중 문제가 발생하면 일부 Member만 차단 상태가 되어 일관성이 깨지게 됩니다.

따라서, 트랙잭션 관리를 위해 트랜잭션의 범위를 응용서비스로 해야합니다.

## 도메인 로직 넣지 않기

도메인 로직은 도메인 영역에 위치하고 응용서비스는 도메인 로직을 구현하지 않습니다.

예를 들어 암호변경 기능의 경우 다음과 같은 모습이어야 합니다.

```java
public Class ChangePasswordService {
	public void changePassword(String memberId, String oldPw, String newPw) {
		Member member = memberRepository.findById(memberId);
		checkMember(member);
		member.changePassword(oldPw,newPw);
	}
}
```

멤버 애그리거트는 암호를 변경하기 위해 기존의 암호를 잘 입력했는지 확인하는 로직을 애그리거트에 구현합니다.

```java
public class Member {
	public void changePassword(String oldPw, newPw) {
		if(!matchPassword(oldPw)) throw new BadPasswordException();
		setPassword(newPw);
	}
	public boolean matchPassword(String pwd) {
		return passwordEncoder.matches(pwd);
	}
	private void setPassword(String newPw) {
		if (isEmpty(newPw)) throw new IllegalArgumentException(“no new Password”);
		this.password = newPw;
	}
}
```


하기의 경우는 있어서는 안된다.

```java
public class ChangePasswordService {
	public void changePassword(String memberId, String oldPw, String newPw) {
		Member member = memberRepository.findById(memberId);
		checkMember(member);
		if (!passwordEncoder.matches(oldPw, member.getPassword()) {
			throw new BadPasswordException();
		}
		member.setPassword(newPw);
	}
}
```

#### 응용서비스에 도메인 로직이 들어가서는 안되는 이유

