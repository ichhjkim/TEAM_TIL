# 스프링 인 액션 책 정리 

<1장>

스프링은 Spring Application Context 라는 컨테이너를 제공한다. 
이것은 애플리케이션 '컴포넌트' 들을 생성하고 관리한다. 

'컴포넌트'와 '빈'은 컨텍스트 내부에서 연결되어 애플리케이션을 구성한다.   

빈의 상호연결은 dependency injection 의존성 주입 패턴을 기반으로 수행됨. 
애플리케이션 컴포넌트에서 의존(사용) 하는 다른 빈의 생성과 관리를 별도의 개체가 해주며, 이 개체에서 모든 컴포넌트를 생성, 관리하고 그 컴포넌트를 필요로 하는 빈에 주입(연결) 한다. 

생성자의 인자 (param) 또는 접근자 메서드를 통해 처리됨.

기존에는 xml 방식이었다면 지금은 자바 기반의 어노테이션을 더 많이 사용함.

@Configuration 
=> 각 빈을 스프링 어플리케이션 컨텍스트에 제공하는 구성 클래스라는 것을 스프링에게 알려줌. 

@Bean
=> Confiuration 클래스의 메서드에 지정. 각 메서드에서 반환되는 객체가 애플리케이션 컨텍스트의 빈으로 추가된다.


자동 구성 기능을 가지고 있어서 이 클래스를 구현할 필요는 없지만, 이것이 불가능한 경우에만 사용하면 된다. 

자동-구성은 자동연결(autowiring) 과 컴포넌트 검색(component scanning) 이라는 스프링 기법을 기반으로 함. 
컴포넌트 검색으로 자동으로 애플리케이션의 classpath에 지정된 컴포넌트를 찾아서 컨텍스트의 빈으로 생성하고, 의존관계가 있는 컴포넌트들을 자동으로 다른 빈에 주입(연결)한다.


주로 어플리케이션 신규 생성 시에는 Spring Initializer 를 사용한다. 직접 웹사이트에 접속도 가능하고, 보통 IDE에서 해당 기능을 지원함.


생성하고 나서 확인해 볼 것. 
- pom.xml

<parent> - <version> : 우리 프로젝트의 부모 POM (Project Object Model) 으로 spring-boot-starter-parent 를 가진다는 것을 지정. 부모 POM은 라이브러리의 의존성 관리를 제공. 해당 스프링 부트 버전에 정의된 의존성 관리를 계승한다.

<dependencies> : 의존성 정의. 프로젝트 위저드에서 선택한 각 의존성이 지정된다. 
spring web, thymeleaf, test  의존성 항목은 artifactid에 starter를 포함하고 있는데, 이것은 스프링부트 스타터의 의존성을 나타낸다. 자체적으로 라이브러리 코드를 가지지 않고,다른 라이브러리의 것을 사용.
=> 이러한 스타터 의존성의 장점 : 모든 라이브러리의 의존성을 선언하지 않아도 되므로 빌드 파일이 작아지고 관리하기 쉬워짐. 
=> 기능의 관점으로 의존성을 생각할 수 있음
=> 라이브러리의 버전을 스프링 부트에서 관리해주므로 부트 버전만 신경쓰면 됨.

<build> : 빌드 명세 지정. 스프링 부트 플러그인이 지정. 메이븐 사용하는 애플리케이션 실행할 수 있도록. 의존성에 지정된 라이브러리가 JAR  파일에 포함되어 있는지, 런타임 시에 classpath에서 찾을 수 있는지 확인한다. 실행가능 JAR 파일의 메인 클래스로 부트스트랩 클래스를 나타내는 매니페스트 파일을 JAR파일에 생성.


어플리케이션의 부트스트랩(실행, 구동) 
JAR 파일에서 어플리케이션 - 제일 먼저 시작되는 부트스트랩 클래스 필요. + 애플리케이션 구동을 위한 최소한의 스프링 구성도 필요.
최초에 선언한 파일명 기준으로 
src/main/java => 파일명.java


@SpringBootApplication => 스프링부트 어플리케이션이다. 
@SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan 3개 어노테이션의 합임.

@SpringBootConfiguration : 현재 클래스를 구성 클래스로 지정. @Configuration 의 특화된 형태임. 
@EnableAutoConfiguration : 스프링부트 자동구성을 활성화함. 
@ComponentScan : 컴포넌트 검색을 활성화한다. @Component, @Controller, @Service 등을 사용가능. 이 어노테이션을 쓰면, 스프링 애플리케이션 컨텍스트에 추가하도록 함.


애플리케이션 테스트 

@SpringBootTest : 스프링부트 기능으로 테스트 시작 -> Junit에 전달
테스트 메서드가 없다면 아무일도 안하지만, 내부가 비어있더라도 일단 메서드가 선언되어 있다면 정상적으로 애플리케이션 컨텍스트가 로드되는지 확인하고 알려준다. 문제가 있으면 실패함.




# 스프링 애플리케이션 작성하기

## 홈페이지 작성
1. 홈페이지 웹 요청을 처리하는 컨트롤러 클래스
2. 홈페이지 모습을 정의하는 뷰 템플릿
3. 테스트 클래스 작성

### 웹요청 처리하기 
MVC 웹 프레임워크. 핵심에는 컨트롤러가 있으며, 웹 요청과 응답을 처리하는 컴포넌트. 
선택적으로 모델 데이터를 채워서 응답하며 브라우저에 반환되는 HTML 을 생성하기 위해 해당 응답의 웹 요청을 뷰에 전달함.

컨트롤러 메서드에서는 뷰 이름을 반환한다. (템플릿 엔진을 사용할 때만 해당되나??)
FO 를 담당하는 경우에는 React, Vue, JSP 등을 이용가능하고, 또 템플릿 엔진을 이용하는 방법도 있다. 

템플릿 엔진을 이용할 때는 논리적 뷰 이름 앞에 /templates/ 가 추가되고 끝에는 .html 이 추가되어야 한다. 이것은 java 파일이 아니므로 resource 폴더에 저장되어야 한다.

Thymeleaf 템플릿 엔진 사용. 
상대경로 사용시에는 @{...} 표현식 사용
정적인 콘텐츠는 /src/main/resources/static/ 폴더에 저장되어야 한다.


### 스프링부트 DevTools

- 코드 변경시에 자동으로 애플리케이션 재시작. 
- 브라우저로 전송되는 리소스가 변경시 자동으로 브라우저 새로고침
- 템플릿 캐시 자동 비활성화
- H2 DB 자동으로 콘솔 활성화 
- 운영시에는 자동으로 비활성화


Devtools 를 사용중일 때는 JVM에서 두 개의 클래스 로더에 의해 로드되는데, 그 중하나는 src/main/ 경로에 있는 모든 것과 함께 로드된다. 나머지 클래스 로더는 자주 변경되지 않는 의존성 라이브러리와 함께 로드된다. 
변경 감지시에 프로젝트 코드를 포함하는 클래스 로더만 다시 로드해서 스프링 애플리케이션 컨텍스트를 재시작시킨다. 
따라서 의존성 변경은 적용될 수 없으므로, 빌드 명세 pom.xml 을 변경시에는 애플리케이션을 재시작해야한다. (리소스 변경시에도?)


<템플릿 캐시 비활성화>
Thymeleaf  같은 템플릿은 템플릿의 파싱 결과를 캐시에 저장하고 사용한다. 요청시마다 파싱하지 않기 위해서 실제 운영에는 좋으나 개발에서는 유용하지 않다.
라이브리로드 서버도 활성화해서 브라우저에 전달되는 거의 모든 것의 변경이 생길 때 브라우저가 자동으로 새로고침됨.(라이브 리로드 플러그인이 각 브라우저에 설치되어 있을 경우)
http://livereload.com/extensions  참조.


### 핵심 스프링 프레임워크
- MVC  템플릿 구조
- REST API rnwh
- 템플릿 기반의 JDBC 지원
- 리액티브 프로그래밍 지원

### 스프링부트

### 스프링데이터
- JPA RDBMS 
- MONGO Document
- Neo4j graph
다양한 디비와 함께 사용가능

### 스프링 시큐리티
- 인증
- 허가
- API 보안

### 스프링 통합과 배치 

### 스프링 클라우드
- 스프링 마이크로서비스 코딩 공작소 책 추천





<2장 웹 애플리케이션 개발하기>
- 내부도 중요하지만, 처음에 보이는 외부의 것 또한 중요하다.
- 첫 인장은 UI에서 

- 스프링 웹 애플리케이션에서 데이터를 가져오고 , 처리하는 것이 컨트롤러의 일. 
- 브라우저에 보여주는 데이터를 HTML 로 나타내는 것은 뷰가 하는 일. 

=> 
타코 식자재를 보여주고, 고객이 선택할 수 있는 페이지를 구성하기 위해서 새로 추가될 컴포넌트. 
- 타코 식자재 속성 정의하는 도메인 클래스
- 식자재 정보를 가져와서 뷰에 전달하는 스프링 MVC 컨트롤러 클래스
- 식자재 내역을 사용자의 브라우저에 보여주는 뷰 템플릿


## 도메인 설정하기

- 애플리케이션 도메인은 해당 애플리케이션의 이해에 필요한 개념을 다루는 영역. 

ex) 타코 관련 애플리케이션의 도메인 객체 : 고객이 선택한 타코 디자인, 디자인을 구성하는 식자재, 고객, 고객의 타코 주문 등


타코 식자재(Ingredient Class) : 타입, 이름, ID
lombok 을 사용하면, 런타임 시에 자동으로 생성한다. 
@Data  애노테이션 지정하면, 누락된 final 속성을 초기화하고, getter setter  생성을 lombok 에 알려준다.


의존성으로 추가해야하는데, 패키지 탐색기의 pom.xml 에서 우클릭 ->스프링 컨텍스트 메뉴 -> edit starters 선택하고 변경.
STS 가 자동으로 빌드 명세에 추가함. 혹은 수동으로 입력가능

런타임 시에는 에러가 없어도, 소스 작성 시점에는 없다고 에러를 보여준다. IDE가 . 
이걸 막기위해 sts 확장으로 lombok 추가 필요함.

lombok 을 공식 홈페이지에서 다운로드 
http://www.projectlombok.org/download  
다운된 롬복.jar 파일을 STS 실행파일이 있는 디렉터리에 복사
SpringToolSuite4.ini 파일을 열고 제일 끝에 한 줄 추가함. 
재시작. (설정 오류시에는 재시작 안됨)

맥북에서는 다운받은 경로를 application 정확히 체크 필요함.


# 2. 폼 제출 처리하기

Lombok의  @Slf4j  어노테이션을 사용하면 컴파일 시에 Logger  객체를 생성할 수 있다. 이걸로 바로 로그 기록 가능하다. 

스프링 2.3 버전이상부터는 더 이상 자바 8을 사용할 수 없다. 그렇지 않으면 스프링 이니셜 라이저로 생성은 가능하나 실제 빌드시에 오류가 난다. 
마찬가지로 유효성검사를 위한 Bean Validation 역시 2.3 이후로는 별도 모듈로 빠져서 추가해서 사용해야 한다.
<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
			<version>2.6.7</version>
		</dependency>

maven 사용시에 위에 처럼 추가가 필요함. 
근데 바로 입력은 안되는 것 같던데...? 뭔가 시스템으로 입력해야 잘 들어가던데 리프레시가 필요한가?

Data 선언부 혹은 DTO 선언부에서 
@NotNull : 값이 없거나 null인지
@Size : 최대, 최소 자릿수 혹은 갯수
@NotBlank : 입력여부
@CreditCardNumber : 신용카드 형식 만족 여부
@Pattern : 정규식 등의 패턴 만족 여부
@Digits : 숫자 자릿수 만족 여부 


이후 해당 데이터를 입력 받는 Controller 단에서 
@Valid Taco taco 등으로 적절한 데이터가 들어오는지를 체크하고, 에러가 발생하면 에러에 따라서 응답을 리턴한다. 
Errors erros 를 인수로 받음. 실제 입력은 모델만.


템플릿 캐싱 끄기- 프로덕션 배포시에는 삭제하거나 true 로 변경할 것